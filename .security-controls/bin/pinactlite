#!/usr/bin/env bash
set -euo pipefail

# Version information
PINACTLITE_VERSION="1.0.0"
PINACTLITE_BUILD_DATE="2025-10-22"

usage() {
  cat <<USG
pinactlite (script) - pinning validator and autopinner v${PINACTLITE_VERSION}

Usage:
pinactlite pincheck [--dir DIR]
pinactlite autopin  [--dir DIR] [--actions] [--images] [--dry-run] [--quiet]
pinactlite run      [--dir DIR] [--actions] [--images] [--dry-run] [--quiet]
pinactlite generate-renovate-config [FILE]
pinactlite --version
pinactlite --help

Commands:
  pincheck                  Check that GitHub Actions and container images are pinned to immutable refs
  autopin                   Rewrite unpinned refs to immutable SHAs/digests (exits 2 if changes made)
  run                       Check and pin references (combines pincheck + autopin, pinact-compatible)
  generate-renovate-config  Generate Renovate config for keeping pinned actions updated

Options:
  --dir DIR   Workflow directory (default .github/workflows)
  --actions   Include GitHub Actions uses: lines
  --images    Include container/services images and docker:// actions
  --dry-run   Do not write changes; print what would change
  --quiet     Suppress normal output (errors still printed)
  --version   Show version information
  --help      Show this help message
USG
}

show_version() {
  cat <<VER
pinactlite version ${PINACTLITE_VERSION}
Build date: ${PINACTLITE_BUILD_DATE}
Platform: $(uname -s) $(uname -m)
VER
}

# Global caches for performance
declare -A SHA_CACHE
declare -A IMAGE_DIGEST_CACHE
declare -A METRICS
METRICS["actions_checked"]=0
METRICS["actions_pinned"]=0
METRICS["images_checked"]=0
METRICS["images_pinned"]=0
METRICS["cache_hits"]=0
METRICS["cache_misses"]=0

is_hex40() {
  local s="$1"
  [[ ${#s} -eq 40 && $s =~ ^[0-9a-fA-F]{40}$ ]]
}

trim_quotes() {
  local v="$1"
  v="${v%\r}"
  v="${v#\' }"
  v="${v#\" }"
  v="${v%\' }"
  v="${v%\" }"
  v="${v#\'}"
  v="${v#\"}"
  v="${v%\' }"
  v="${v%\" }"
  echo "$v"
}

say() { [[ ${QUIET:-0} == 1 ]] || echo "$@"; }

check_uses_line() {
  local file="$1" loc="$2" val="$3"
  val="$(trim_quotes "$val")"
  METRICS["actions_checked"]=$((${METRICS["actions_checked"]} + 1))

  # skip local actions
  if [[ $val == ./* || $val == .github/* ]]; then
    return 0
  fi

  # Check allowlist
  if is_in_allowlist "$val"; then
    say "Skipping $val (in allowlist)" >&2
    return 0
  fi
  if [[ $val == docker://* ]]; then
    if [[ $val != *"@sha256:"* ]]; then
      cat >&2 <<EOF
$file: $loc: Unpinned docker action detected
  Action: $val
  Issue: Missing @sha256: digest pin

  â†’ Fix: Run auto-pin to resolve
    $ pinactlite autopin --dir .github/workflows

  â†’ Or let pre-push hook auto-fix on next commit
EOF
      return 1
    fi
    return 0
  fi
  # expect owner/repo[@ref]
  if [[ $val != *"@"* ]]; then
    cat >&2 <<EOF
$file: $loc: Unpinned action detected
  Action: $val
  Issue: Missing version reference (no @<ref>)

  â†’ Fix: Run auto-pin to resolve
    $ pinactlite autopin --dir .github/workflows

  â†’ Or let pre-push hook auto-fix on next commit
EOF
    return 1
  fi
  local ref="${val##*@}"
  if ! is_hex40 "$ref"; then
    local action_name="${val%@*}"
    cat >&2 <<EOF
$file: $loc: Unpinned action detected
  Action: $val
  Issue: Not pinned to 40-character SHA hash (currently: @${ref})

  â†’ Fix: Run auto-pin to resolve
    $ pinactlite autopin --dir .github/workflows

  â†’ Or let pre-push hook auto-fix on next commit

  â„¹ï¸  SHA pinning protects against:
     â€¢ Malicious updates to action code
     â€¢ Supply chain attacks via compromised tags
     â€¢ Unexpected breaking changes
EOF
    return 1
  fi
  return 0
}

# Resolve owner/repo@ref to a commit SHA (uses git ls-remote with caching)
resolve_action_sha() {
  local owner_repo="$1" ref="$2"
  local cache_key="${owner_repo}@${ref}"

  # Check cache first
  if [[ -n "${SHA_CACHE[$cache_key]:-}" ]]; then
    METRICS["cache_hits"]=$((${METRICS["cache_hits"]} + 1))
    echo "${SHA_CACHE[$cache_key]}"
    return 0
  fi

  METRICS["cache_misses"]=$((${METRICS["cache_misses"]} + 1))
  local url="https://github.com/${owner_repo}.git"
  local sha

  # Try exact match (tag or branch)
  sha=$(git ls-remote "$url" "$ref" </dev/null 2>/dev/null | awk '{print $1}' | head -1 || true)
  if [[ -z $sha ]]; then
    # Try tags/
    sha=$(git ls-remote "$url" "refs/tags/$ref" </dev/null 2>/dev/null | awk '{print $1}' | head -1 || true)
  fi
  if [[ -z $sha ]]; then
    # Try heads/
    sha=$(git ls-remote "$url" "refs/heads/$ref" </dev/null 2>/dev/null | awk '{print $1}' | head -1 || true)
  fi

  # Validate SHA exists in remote if we got one
  if [[ -n $sha ]] && is_hex40 "$sha"; then
    # Verify SHA exists in repository
    if git ls-remote "$url" | grep -q "^${sha}"; then
      SHA_CACHE[$cache_key]="$sha"
      echo "$sha"
    else
      say "Warning: SHA $sha not found in remote repository $owner_repo" >&2
      return 1
    fi
  elif [[ -n $sha ]]; then
    SHA_CACHE[$cache_key]="$sha"
    echo "$sha"
  fi
}

# Resolve a Docker/OCI image tag to a digest (Docker Hub public and GHCR public best-effort with caching)
resolve_image_digest() {
  local image="$1"

  # Already pinned
  [[ $image == *"@sha256:"* ]] && {
    echo "$image"
    return 0
  }

  # Check cache first
  if [[ -n "${IMAGE_DIGEST_CACHE[$image]:-}" ]]; then
    METRICS["cache_hits"]=$((${METRICS["cache_hits"]} + 1))
    echo "${IMAGE_DIGEST_CACHE[$image]}"
    return 0
  fi

  METRICS["cache_misses"]=$((${METRICS["cache_misses"]} + 1))

  # Parse image components
  local registry="" namespace="" name="" tag="latest"
  local remaining="$image"

  # Extract registry if present
  if [[ $remaining == *"/"*"/"* ]]; then
    registry="${remaining%%/*}"
    remaining="${remaining#*/}"
  fi

  # Extract namespace/name and tag
  if [[ $remaining == *":"* ]]; then
    tag="${remaining##*:}"
    remaining="${remaining%:*}"
  fi

  if [[ $remaining == *"/"* ]]; then
    namespace="${remaining%/*}"
    name="${remaining##*/}"
  else
    name="$remaining"
  fi

  # Try different registries
  local digest=""

  # Docker Hub
  if [[ -z $registry || $registry == "docker.io" ]]; then
    local repo_path="${namespace:+$namespace/}$name"
    [[ $namespace == "library" ]] && repo_path="$name"

    digest=$(curl -sSL -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
      "https://registry-1.docker.io/v2/$repo_path/manifests/$tag" 2>/dev/null |
      jq -r '.config.digest // empty' 2>/dev/null || true)
  fi

  # GHCR
  if [[ -z $digest && ($registry == "ghcr.io" || -z $registry) ]]; then
    local repo_path="${namespace:+$namespace/}$name"
    digest=$(curl -sSL -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
      "https://ghcr.io/v2/$repo_path/manifests/$tag" 2>/dev/null |
      jq -r '.config.digest // empty' 2>/dev/null || true)
  fi

  if [[ -n $digest ]]; then
    local result="${registry:+$registry/}${namespace:+$namespace/}$name@$digest"
    IMAGE_DIGEST_CACHE[$image]="$result"
    echo "$result"
  else
    return 1
  fi
}

# Very simple YAML walker for container/services images (validation)
check_images_in_yaml() {
  local file="$1"
  local violations=0
  rm -f "$file.uses.tmp"
  awk -v FNAME="$file" -v UFILE="$file.uses.tmp" '
    function ltrim(s) { sub(/^[ \t]+/, "", s); return s }
    function indent(s) { match(s, /^ */); return RLENGTH }
    BEGIN{ in_container=0; cont_indent=0; in_services=0; serv_indent=0; in_block=0; block_indent=0 }
    /^[[:space:]]*#/ { next }
    {
      line=$0
      ind=indent(line)
      l=ltrim(line)

      # Track YAML block scalars (e.g., "run: |" or "run: >").
      # When inside a block scalar, ignore its content lines for checks.
      if (in_block) {
        # Exit block if we reach a line with same or lesser indentation than the block header,
        # but skip blank lines as they do not end the block
        if (l ~ /^$/) { next }
        if (ind <= block_indent) { in_block=0 } else { next }
      }
      if (l ~ /:[[:space:]]*[|>][+-]?([[:space:]]*#.*)?$/) {
        in_block=1; block_indent=ind; next
      }

      if (l ~ /^container:/) {
        if (l ~ /^container:[[:space:]]*[^\{\[]/) {
          img=l; sub(/^container:[[:space:]]*/, "", img)
          if (img !~ /@sha256:/) { printf "%s: jobs.container: image not pinned: %s\n", FNAME, img; violations++ }
        } else {
          in_container=1; cont_indent=ind
        }
      } else if (in_container && ind <= cont_indent) { in_container=0 }
      if (l ~ /^services:/) { in_services=1; serv_indent=ind; next }
      if (in_services && ind <= serv_indent) { in_services=0 }
      if ((in_container || in_services) && l ~ /^image:[[:space:]]*/) {
        img=l; sub(/^image:[[:space:]]*/, "", img)
        gsub(/^"|"$/, "", img); gsub(/^\047|\047$/, "", img)
        if (img !~ /@sha256:/) { printf "%s: image not pinned: %s\n", FNAME, img; violations++ }
      }
      if (!in_container && !in_services && l ~ /^image:[[:space:]]*/) {
        img=l; sub(/^image:[[:space:]]*/, "", img)
        gsub(/^"|"$/, "", img); gsub(/^\047|\047$/, "", img)
        if (img ~ /[A-Za-z0-9_\-]+\/[A-Za-z0-9_\-]+/ && img !~ /@sha256:/) {
          printf "%s: image not pinned: %s\n", FNAME, img; violations++
        }
      }
      # Match "uses:" pattern (without dash, as dash is on the step "- name:" line)
      if (l ~ /^uses: */) {
        val=l; sub(/^uses: */, "", val)
        # Remove inline comments
        sub(/ *#.*$/, "", val)
        gsub(/^"|"$/, "", val); gsub(/^\047|\047$/, "", val)
        printf "USES %s\n", val >> UFILE
      }
    }
    END{ if (violations>0) exit 2 }
  ' "$file" || return 2
  local rc=0
  if [[ -s "$file.uses.tmp" ]]; then
    while IFS= read -r line; do
      [[ $line != USES* ]] && continue
      local val="${line#USES }"
      if ! check_uses_line "$file" "uses" "$val"; then rc=1; fi
    done <"$file.uses.tmp"
    rm -f "$file.uses.tmp"
  fi
  return $rc
}

rewrite_actions_in_file() {
  local file="$1" changed=0 tmp
  tmp=$(mktemp)
  while IFS= read -r line; do
    # Match lines with 'uses:' (may have leading dash and spaces like "  - uses:")
    if [[ $line =~ uses:[[:space:]]* ]]; then
      local raw="${line#*uses:}"
      raw=$(echo "$raw" | sed -E "s/^[[:space:]]+//; s/[\"']+//g")

      # Extract existing comment if present (everything after # except in strings)
      local existing_comment=""
      if [[ $line =~ \#[[:space:]]*(.*)[[:space:]]*$ ]]; then
        existing_comment="${BASH_REMATCH[1]}"
      fi

      if [[ $raw == docker://* ]]; then
        : # handled by images rewrite
      else
        # owner/repo@ref
        local or="${raw%@*}" ref="${raw##*@}"
        if [[ -n $ref ]] && ! is_hex40 "$ref"; then
          local sha
          sha=$(resolve_action_sha "$or" "$ref" || true)
          if [[ -n $sha ]]; then
            local newline
            # Escape any characters in ref that might confuse sed
            local escaped_ref="${ref//\//\\/}"

            # Smart comment preservation: add version tag and preserve existing comments
            local comment_part="${escaped_ref}"
            if [[ -n $existing_comment ]]; then
              # Preserve existing comment alongside version tag
              comment_part="${escaped_ref} | ${existing_comment}"
            fi

            newline=$(echo "$line" | sed -E "s|([[:space:]]*uses:[[:space:]]*[\\\"\\']?)${or}@[^\\\"'#[:space:]]+.*|\\1${or}@${sha} # ${comment_part}|")
            if [[ $newline != "$line" ]]; then
              line="$newline"
              changed=1
              METRICS["actions_pinned"]=$((${METRICS["actions_pinned"]} + 1))
              say "Pinned action ${or}@${ref} -> ${sha} in ${file}" >&2
            fi
          fi
        fi
      fi
    fi
    echo "$line"
  done <"$file" >"$tmp"
  if [[ $changed -eq 1 && ${DRY_RUN:-0} -ne 1 ]]; then
    cp "$file" "$file.bak.pin"
    mv "$tmp" "$file"
  else
    rm -f "$tmp"
  fi
  return $changed
}

# Clean up old backup files (older than 7 days)
cleanup_backup_files() {
  local dir="${1:-.github/workflows}"
  if [[ -d "$dir" ]]; then
    find "$dir" -name "*.bak.pin" -mtime +7 -delete 2>/dev/null || true
    say "Cleaned up old backup files in $dir" >&2
  fi
}

# Check if action/image is in bypass allowlist
is_in_allowlist() {
  local ref="$1"
  local allowlist=".security-controls/pinning-allowlist.txt"

  [[ ! -f $allowlist ]] && return 1

  # Check for exact match or pattern match
  while IFS= read -r line; do
    # Skip comments and empty lines
    [[ $line =~ ^[[:space:]]*# ]] && continue
    [[ -z $line ]] && continue

    # Trim whitespace
    line=$(echo "$line" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')

    # Check for match
    if [[ $ref == $line ]]; then
      return 0
    fi
  done < "$allowlist"

  return 1
}

# Check composite actions (.github/actions/*/action.yml)
check_composite_actions() {
  local actions_dir=".github/actions"
  local violations=0

  if [[ ! -d $actions_dir ]]; then
    return 0
  fi

  while IFS= read -r -d '' action_file; do
    if ! check_images_in_yaml "$action_file"; then
      violations=$((violations + 1))
    fi
  done < <(find "$actions_dir" -type f \( -name "action.yml" -o -name "action.yaml" \) -print0)

  return $violations
}

# Generate Renovate configuration for pinned actions
generate_renovate_config() {
  local config_file="${1:-renovate.json}"

  cat > "$config_file" <<'RENOVATE'
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "description": "Auto-generated by pinactlite - Keep pinned GitHub Actions updated",
  "extends": ["config:base"],
  "github-actions": {
    "enabled": true,
    "pinDigests": true,
    "addLabels": ["dependencies", "github-actions", "auto-pinned"],
    "automerge": false,
    "schedule": ["before 6am on monday"],
    "commitMessagePrefix": "chore(actions): "
  },
  "docker": {
    "pinDigests": true,
    "addLabels": ["dependencies", "docker"],
    "automerge": false
  },
  "packageRules": [
    {
      "description": "Group GitHub Actions updates",
      "matchManagers": ["github-actions"],
      "groupName": "GitHub Actions"
    }
  ]
}
RENOVATE

  say "Generated Renovate config at $config_file" >&2
  say "Run 'renovate' to automatically update pinned actions" >&2
}

# Display metrics summary
show_metrics() {
  if [[ ${QUIET:-0} == 1 ]]; then
    return 0
  fi

  cat >&2 <<METRICS

ðŸ“Š Pinactlite Metrics Summary
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Actions checked:     ${METRICS["actions_checked"]}
Actions pinned:      ${METRICS["actions_pinned"]}
Images checked:      ${METRICS["images_checked"]}
Images pinned:       ${METRICS["images_pinned"]}
Cache hits:          ${METRICS["cache_hits"]}
Cache misses:        ${METRICS["cache_misses"]}

METRICS

  # Calculate and show cache hit rate if there were cache operations
  local total_cache_ops=$((${METRICS["cache_hits"]} + ${METRICS["cache_misses"]}))
  if [[ $total_cache_ops -gt 0 ]]; then
    local hit_rate=$((${METRICS["cache_hits"]} * 100 / total_cache_ops))
    echo "Cache hit rate:      ${hit_rate}%" >&2
  fi
}

rewrite_images_in_file() {
  local file="$1" changed=0 tmp
  tmp=$(mktemp)
  while IFS= read -r line; do
    local ltrimmed=$(echo "$line" | sed -E "s/^[[:space:]]+//")
    if [[ $ltrimmed =~ ^(image:|container:) ]]; then
      local val=$(echo "$line" | sed -E "s/^[^:]+:[[:space:]]*//; s/[\"']+//g")
      METRICS["images_checked"]=$((${METRICS["images_checked"]} + 1))
      if [[ $val != *"@sha256:"* ]]; then
        local pinned
        pinned=$(resolve_image_digest "$val" || true)
        if [[ -n $pinned ]]; then
          local newline
          newline=$(echo "$line" | sed -E "s#(image:|container:)[[:space:]]*[\"\']?[^\"'[:space:]]+#\\1 ${pinned}#")
          if [[ $newline != "$line" ]]; then
            line="$newline"
            changed=1
            METRICS["images_pinned"]=$((${METRICS["images_pinned"]} + 1))
            say "Pinned image ${val} -> ${pinned} in ${file}" >&2
          fi
        fi
      fi
    fi
    if [[ $ltrimmed =~ ^uses:\s*docker:// ]]; then
      local val=$(echo "$line" | sed -E "s/^[[:space:]]*uses:[[:space:]]*//; s/[\"']+//g")
      METRICS["images_checked"]=$((${METRICS["images_checked"]} + 1))
      if [[ $val != *"@sha256:"* ]]; then
        local pinned
        pinned=$(resolve_image_digest "$val" || true)
        if [[ -n $pinned ]]; then
          local newline
          newline=$(echo "$line" | sed -E "s#uses:[[:space:]]*[\"\']?docker://[^\"'[:space:]]+#uses: ${pinned}#")
          if [[ $newline != "$line" ]]; then
            line="$newline"
            changed=1
            METRICS["images_pinned"]=$((${METRICS["images_pinned"]} + 1))
            say "Pinned docker action ${val} -> ${pinned} in ${file}" >&2
          fi
        fi
      fi
    fi
    echo "$line"
  done <"$file" >"$tmp"
  if [[ $changed -eq 1 && ${DRY_RUN:-0} -ne 1 ]]; then
    cp "$file" "$file.bak.pin"
    mv "$tmp" "$file"
  else
    rm -f "$tmp"
  fi
  return $changed
}

cmd_pincheck() {
  local dir=".github/workflows"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dir)
        dir="$2"
        shift 2
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      --quiet)
        QUIET=1
        shift
        ;;
      *)
        echo "Unknown option: $1" >&2
        usage
        exit 2
        ;;
    esac
  done
  local count=0

  # Check workflows
  if [[ -d $dir ]]; then
    while IFS= read -r -d '' f; do
      if ! check_images_in_yaml "$f"; then
        count=$((count + 1))
      fi
    done < <(find "$dir" -type f \( -name "*.yml" -o -name "*.yaml" \) -print0)
  fi

  # Check composite actions
  if ! check_composite_actions; then
    count=$((count + 1))
  fi

  if [[ $count -gt 0 ]]; then
    echo "Unpinned references detected: $count" >&2
    return 1
  fi
  say "All workflows and composite actions are pinned to immutable SHAs/digests."
  return 0
}

cmd_autopin() {
  local dir=".github/workflows" do_actions=1 do_images=1 DRY_RUN=0 QUIET=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dir)
        dir="$2"
        shift 2
        ;;
      --actions)
        do_actions=1
        shift
        ;;
      --no-actions)
        do_actions=0
        shift
        ;;
      --images)
        do_images=1
        shift
        ;;
      --no-images)
        do_images=0
        shift
        ;;
      --dry-run)
        DRY_RUN=1
        shift
        ;;
      --quiet)
        QUIET=1
        shift
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1" >&2
        usage
        exit 2
        ;;
    esac
  done

  # Clean up old backup files
  cleanup_backup_files "$dir"

  local changed_any=0
  if [[ -d $dir ]]; then
    while IFS= read -r -d '' f; do
      local changed=0 rc=0
      if [[ $do_actions -eq 1 ]]; then
        set +e
        rewrite_actions_in_file "$f"
        rc=$?
        set -e
        if [[ $rc -gt 0 ]]; then
          changed=1
          changed_any=1
        fi
      fi
      if [[ $do_images -eq 1 ]]; then
        set +e
        rewrite_images_in_file "$f"
        rc=$?
        set -e
        if [[ $rc -gt 0 ]]; then
          changed=1
          changed_any=1
        fi
      fi
    done < <(find "$dir" -type f \( -name "*.yml" -o -name "*.yaml" \) -print0)
  fi

  # Show metrics
  show_metrics

  if [[ $changed_any -eq 1 ]]; then
    say "Pinned references updated. Review changes, commit, and push again."
    return 2
  fi
  say "No changes needed."
  return 0
}

cmd_run() {
  local dir=".github/workflows" do_actions=1 do_images=1 DRY_RUN=0 QUIET=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dir)
        dir="$2"
        shift 2
        ;;
      --actions)
        do_actions=1
        shift
        ;;
      --no-actions)
        do_actions=0
        shift
        ;;
      --images)
        do_images=1
        shift
        ;;
      --no-images)
        do_images=0
        shift
        ;;
      --dry-run)
        DRY_RUN=1
        shift
        ;;
      --quiet)
        QUIET=1
        shift
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1" >&2
        usage
        exit 2
        ;;
    esac
  done

  # First run pincheck to validate current state
  say "Checking for unpinned references..."
  local pincheck_failed=0
  if [[ -d $dir ]]; then
    while IFS= read -r -d '' f; do
      if ! check_images_in_yaml "$f"; then
        pincheck_failed=1
      fi
    done < <(find "$dir" -type f \( -name "*.yml" -o -name "*.yaml" \) -print0)
  fi

  # If pincheck found issues, run autopin to fix them
  if [[ $pincheck_failed -eq 1 ]]; then
    say "Found unpinned references. Running autopin to fix them..."

    # Run autopin with the same arguments
    local changed_any=0
    if [[ -d $dir ]]; then
      while IFS= read -r -d '' f; do
        local changed=0 rc=0
        if [[ $do_actions -eq 1 ]]; then
          set +e
          rewrite_actions_in_file "$f"
          rc=$?
          set -e
          if [[ $rc -gt 0 ]]; then
            changed=1
            changed_any=1
          fi
        fi
        if [[ $do_images -eq 1 ]]; then
          set +e
          rewrite_images_in_file "$f"
          rc=$?
          set -e
          if [[ $rc -gt 0 ]]; then
            changed=1
            changed_any=1
          fi
        fi
      done < <(find "$dir" -type f \( -name "*.yml" -o -name "*.yaml" \) -print0)
    fi

    if [[ $changed_any -eq 1 ]]; then
      say "Successfully pinned all references. Please review changes and commit."
      return 0
    else
      say "Could not pin some references. Please check manually."
      return 1
    fi
  else
    say "All references are already pinned."
    return 0
  fi
}

main() {
  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    pincheck) cmd_pincheck "$@" ;;
    autopin) cmd_autopin "$@" ;;
    run) cmd_run "$@" ;;
    generate-renovate-config) generate_renovate_config "$@" ;;
    --version | -v) show_version ;;
    "" | -h | --help) usage ;;
    *)
      echo "Unknown command: $cmd" >&2
      usage
      exit 2
      ;;
  esac
}

main "$@"
