name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v0.3.0)'
        required: true
        type: string

permissions:
  contents: write
  id-token: write
  attestations: write

env:
  CARGO_TERM_COLOR: always

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          fetch-depth: 0  # Fetch all history for changelog generation

      - name: Get version from tag or input
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Triggered by tag push: extract version from ref
            VERSION="${GITHUB_REF#refs/tags/}"
          else
            # Triggered manually: use input
            VERSION="${{ github.event.inputs.tag }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"

      - name: Generate release notes from commits
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 ${VERSION}^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # First release - get all commits
            COMMITS=$(git log --pretty=format:"- %s" --no-merges)
          else
            # Get commits since previous tag
            COMMITS=$(git log --pretty=format:"- %s" --no-merges ${PREV_TAG}..${VERSION})
          fi

          # Generate release notes
          {
            echo "release_notes<<EOF"
            echo "## What's New"
            echo ""
            echo "$COMMITS"
            echo ""
            echo "## Full Changelog"
            if [ -n "$PREV_TAG" ]; then
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${VERSION}"
            fi
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          body: |
            ${{ steps.release_notes.outputs.release_notes }}

            ---

            ## Installation

            ### Windows

            Download and install `nameback-x86_64-pc-windows-msvc.msi`

            **What you get:**
            - ðŸ–¥ï¸ **CLI**: Type `nameback` in any terminal (automatically added to PATH)
            - ðŸŽ¨ **GUI**: Launch from Start Menu â†’ nameback
            - âš™ï¸ **Auto-install dependencies**: exiftool, tesseract, ffmpeg, imagemagick installed automatically

            ### macOS

            **CLI Users (Recommended: Homebrew)**
            ```bash
            brew tap h4x0r/nameback
            brew install nameback
            ```
            Automatically installs all dependencies.

            **GUI Users**
            - Intel Mac: Download `nameback-x86_64-apple-darwin.dmg`
            - Apple Silicon: Download `nameback-aarch64-apple-darwin.dmg`

            Drag to Applications folder and launch!

            ### Linux

            ```bash
            cargo install nameback
            nameback --install-deps
            ```

            ## Verification

            All installers include SHA256 checksums in `checksums.txt`

            ---
            ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
          draft: false
          prerelease: false

  build-release:
    name: Build ${{ matrix.target }}
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            archive: msi

          # macOS Intel
          - target: x86_64-apple-darwin
            os: macos-13
            archive: dmg

          # macOS Apple Silicon
          - target: aarch64-apple-darwin
            os: macos-latest
            archive: dmg

          # Linux (Debian package)
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            archive: deb

    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@21dc36fb71dd22e3317045c0c31a3f4249868b17 # stable
        with:
          toolchain: stable
          targets: ${{ matrix.target }}

      - name: Install dependencies (macOS only)
        if: runner.os == 'macOS'
        run: |
          brew install exiftool tesseract tesseract-lang ffmpeg imagemagick pkg-config

      - name: Cache vcpkg (Windows only)
        if: matrix.os == 'windows-latest'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: C:\vcpkg\installed
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      - name: Install vcpkg and dependencies (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          if (-not (Test-Path C:\vcpkg)) {
            Write-Host "Cloning vcpkg..."
            git clone https://github.com/Microsoft/vcpkg.git C:\vcpkg
          } else {
            Write-Host "vcpkg already exists, skipping clone"
          }
          cd C:\vcpkg
          if (-not (Test-Path .\vcpkg.exe)) {
            Write-Host "Bootstrapping vcpkg..."
            .\bootstrap-vcpkg.bat
          }
          Write-Host "Installing leptonica and tesseract..."
          .\vcpkg integrate install
          .\vcpkg install leptonica:x64-windows-static-md tesseract:x64-windows-static-md

      - name: Set VCPKG_ROOT and triplet (Windows only)
        if: matrix.os == 'windows-latest'
        run: |
          echo "VCPKG_ROOT=C:\vcpkg" >> $GITHUB_ENV
          echo "VCPKGRS_TRIPLET=x64-windows-static-md" >> $GITHUB_ENV
        shell: bash

      - name: Build CLI release binary
        if: matrix.archive != 'deb'
        run: cargo build --release --target ${{ matrix.target }} -p nameback

      - name: Build GUI release binary
        if: matrix.archive != 'deb'
        run: cargo build --release --target ${{ matrix.target }} -p nameback-gui

      - name: Strip binaries (macOS only)
        if: matrix.archive == 'dmg'
        run: |
          strip target/${{ matrix.target }}/release/nameback-gui

      - name: Create DMG installer (macOS only)
        if: matrix.archive == 'dmg'
        run: |
          # Create app bundle structure
          mkdir -p dmg-temp/Nameback.app/Contents/MacOS/bin
          mkdir -p dmg-temp/Nameback.app/Contents/Resources

          # Copy GUI binary
          cp target/${{ matrix.target }}/release/nameback-gui dmg-temp/Nameback.app/Contents/MacOS/nameback-gui
          chmod +x dmg-temp/Nameback.app/Contents/MacOS/nameback-gui

          # Copy CLI binary into app bundle
          cp target/${{ matrix.target }}/release/nameback dmg-temp/Nameback.app/Contents/MacOS/bin/nameback
          chmod +x dmg-temp/Nameback.app/Contents/MacOS/bin/nameback

          # Copy nameback logo as icon (if available)
          if [ -f "docs/nameback.png" ]; then
            # Create iconset for proper macOS app icon
            mkdir -p AppIcon.iconset

            # Generate required icon sizes
            sips -z 16 16     "docs/nameback.png" --out AppIcon.iconset/icon_16x16.png
            sips -z 32 32     "docs/nameback.png" --out AppIcon.iconset/icon_16x16@2x.png
            sips -z 32 32     "docs/nameback.png" --out AppIcon.iconset/icon_32x32.png
            sips -z 64 64     "docs/nameback.png" --out AppIcon.iconset/icon_32x32@2x.png
            sips -z 128 128   "docs/nameback.png" --out AppIcon.iconset/icon_128x128.png
            sips -z 256 256   "docs/nameback.png" --out AppIcon.iconset/icon_128x128@2x.png
            sips -z 256 256   "docs/nameback.png" --out AppIcon.iconset/icon_256x256.png
            sips -z 512 512   "docs/nameback.png" --out AppIcon.iconset/icon_256x256@2x.png
            sips -z 512 512   "docs/nameback.png" --out AppIcon.iconset/icon_512x512.png
            sips -z 1024 1024 "docs/nameback.png" --out AppIcon.iconset/icon_512x512@2x.png

            # Convert iconset to icns
            iconutil -c icns AppIcon.iconset -o dmg-temp/Nameback.app/Contents/Resources/AppIcon.icns

            # Clean up
            rm -rf AppIcon.iconset
          fi

          # Create Info.plist
          cat > dmg-temp/Nameback.app/Contents/Info.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleExecutable</key>
            <string>nameback-gui</string>
            <key>CFBundleIdentifier</key>
            <string>com.securityronin.nameback</string>
            <key>CFBundleName</key>
            <string>Nameback</string>
            <key>CFBundleDisplayName</key>
            <string>Nameback</string>
            <key>CFBundleVersion</key>
            <string>${{ needs.create-release.outputs.version }}</string>
            <key>CFBundleShortVersionString</key>
            <string>${{ needs.create-release.outputs.version }}</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.15</string>
            <key>NSHighResolutionCapable</key>
            <true/>
          </dict>
          </plist>
          EOF

          # Create symlink to /Applications for easy installation
          ln -s /Applications dmg-temp/Applications

          # Create .background directory and copy DMG background image
          mkdir -p dmg-temp/.background
          if [ -f "installer/dmg-assets/dmg-background.png" ]; then
            cp "installer/dmg-assets/dmg-background.png" "dmg-temp/.background/background.png"
          fi

          # Create DMG with custom appearance using AppleScript
          # First create a temporary DMG
          hdiutil create -volname "Nameback" -srcfolder dmg-temp -ov -format UDRW temp.dmg

          # Mount the DMG
          device=$(hdiutil attach -readwrite -noverify -noautoopen "temp.dmg" | egrep '^/dev/' | sed 1q | awk '{print $1}')

          # Set DMG window properties with AppleScript
          echo '
            tell application "Finder"
              tell disk "Nameback"
                open
                set current view of container window to icon view
                set toolbar visible of container window to false
                set statusbar visible of container window to false
                set the bounds of container window to {100, 100, 700, 500}
                set viewOptions to the icon view options of container window
                set arrangement of viewOptions to not arranged
                set icon size of viewOptions to 128
                set background picture of viewOptions to file ".background:background.png"
                set position of item "Nameback.app" of container window to {150, 200}
                set position of item "Applications" of container window to {450, 200}
                close
                open
                update without registering applications
                delay 2
              end tell
            end tell
          ' | osascript

          # Finalize DMG
          chmod -Rf go-w /Volumes/Nameback
          sync

          # Robust unmount with multiple strategies
          echo "Attempting to unmount ${device}..."

          # Strategy 1: Try gentle unmount with retries
          for i in {1..3}; do
            if hdiutil detach ${device} 2>/dev/null; then
              echo "Successfully detached on attempt $i"
              break
            fi
            echo "Detach attempt $i failed, waiting..."
            sleep 3
          done

          # Strategy 2: Check if still mounted and use diskutil
          if diskutil info ${device} >/dev/null 2>&1; then
            echo "Device still mounted, using diskutil unmount force..."
            diskutil unmountDisk force ${device} || true
            sleep 2
          fi

          # Strategy 3: Final force detach
          if diskutil info ${device} >/dev/null 2>&1; then
            echo "Device STILL mounted, using hdiutil detach -force..."
            hdiutil detach ${device} -force || true
            sleep 3
          fi

          # Verify device is unmounted
          if diskutil info ${device} >/dev/null 2>&1; then
            echo "WARNING: Device may still be mounted, checking for blocking processes..."
            lsof | grep ${device} || true
          fi

          # Extra sync and wait for filesystem
          sync
          sleep 5

          # Remove existing output DMG if it exists
          rm -f nameback-${{ matrix.target }}.dmg

          # Convert to compressed DMG
          echo "Converting temp.dmg to final DMG..."
          hdiutil convert temp.dmg -format UDZO -imagekey zlib-level=9 -o nameback-${{ matrix.target }}.dmg

          # Clean up temp files
          rm -f temp.dmg

          # Clean up
          rm -rf dmg-temp

      - name: Generate DMG checksum (macOS only)
        if: matrix.archive == 'dmg'
        run: |
          shasum -a 256 nameback-${{ matrix.target }}.dmg > checksums-${{ matrix.target }}.txt

      - name: Attest DMG installer (macOS only)
        if: matrix.archive == 'dmg'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: nameback-${{ matrix.target }}.dmg

      - name: Install Debian build dependencies (Linux only)
        if: matrix.archive == 'deb'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            debhelper \
            devscripts \
            lintian \
            libimage-exiftool-perl \
            tesseract-ocr \
            ffmpeg \
            imagemagick \
            pkg-config \
            libleptonica-dev \
            libtesseract-dev \
            libclang-dev \
            clang

          # Verify leptonica installation
          echo "Verifying leptonica installation..."
          pkg-config --exists lept && echo "âœ“ lept.pc found" || echo "âœ— lept.pc not found"
          pkg-config --modversion lept || echo "Could not get lept version"
          echo "PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          find /usr -name "lept.pc" 2>/dev/null || echo "lept.pc not found in /usr"

      - name: Build Debian package (Linux only)
        if: matrix.archive == 'deb'
        run: |
          # Set PKG_CONFIG_PATH for the multiarch location
          export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH"
          echo "PKG_CONFIG_PATH is: $PKG_CONFIG_PATH"

          # Verify pkg-config can find lept with the new path
          pkg-config --exists lept && echo "âœ“ pkg-config can find lept" || echo "âœ— pkg-config cannot find lept"
          pkg-config --modversion lept 2>/dev/null && echo "âœ“ lept version: $(pkg-config --modversion lept)" || echo "âœ— Could not get lept version"

          # Build both binaries with PKG_CONFIG_PATH set
          PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH" cargo build --release --workspace

          # Create package structure
          mkdir -p debian-pkg/DEBIAN
          mkdir -p debian-pkg/usr/bin
          mkdir -p debian-pkg/usr/share/applications
          mkdir -p debian-pkg/usr/share/doc/nameback

          # Copy binaries
          cp target/release/nameback debian-pkg/usr/bin/
          cp target/release/nameback-gui debian-pkg/usr/bin/
          chmod 755 debian-pkg/usr/bin/*

          # Copy desktop entry
          cp debian/nameback.desktop debian-pkg/usr/share/applications/

          # Copy documentation
          cp README.md debian-pkg/usr/share/doc/nameback/
          cp LICENSE debian-pkg/usr/share/doc/nameback/copyright

          # Create control file
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NUM=${VERSION#v}  # Remove 'v' prefix
          cat > debian-pkg/DEBIAN/control << EOF
          Package: nameback
          Version: ${VERSION_NUM}-1
          Section: utils
          Priority: optional
          Architecture: amd64
          Depends: libimage-exiftool-perl, tesseract-ocr, tesseract-ocr-chi-tra, tesseract-ocr-chi-sim, ffmpeg, imagemagick
          Maintainer: Albert Hui <albert@example.com>
          Description: Intelligent file renaming based on metadata
           nameback renames files based on their embedded metadata, extracting titles,
           dates, and descriptions to give files meaningful names. It supports a wide
           range of file types including images, videos, PDFs, documents, and more.
           .
           Key Features:
            * Smart metadata extraction from EXIF, PDF, and document fields
            * OCR support for images and video frames (160+ languages)
            * Multi-frame video analysis for better accuracy
            * HEIC/HEIF image support
            * Both CLI and GUI interfaces included
           .
           This package is particularly useful for digital forensics, DFIR workflows,
           organizing recovered files from data recovery tools, and managing large
           photo/video collections.
          Homepage: https://github.com/h4x0r/nameback
          EOF

          # Build .deb package
          dpkg-deb --build --root-owner-group debian-pkg nameback_${VERSION_NUM}-1_amd64.deb

      - name: Run lintian checks (Linux only)
        if: matrix.archive == 'deb'
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NUM=${VERSION#v}
          lintian --no-tag-display-limit nameback_${VERSION_NUM}-1_amd64.deb || true

      - name: Generate DEB checksum (Linux only)
        if: matrix.archive == 'deb'
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NUM=${VERSION#v}
          sha256sum nameback_${VERSION_NUM}-1_amd64.deb > checksums-linux.txt

      - name: Attest Debian package (Linux only)
        if: matrix.archive == 'deb'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: |
            nameback_*_amd64.deb

      - name: Upload Debian package to release (Linux only)
        if: matrix.archive == 'deb'
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: |
            nameback_*_amd64.deb

      - name: Upload installer to release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: |
            nameback-${{ matrix.target }}.${{ matrix.archive }}

      - name: Install WiX Toolset (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          dotnet tool install --global wix
          wix extension add WixToolset.UI.wixext
          wix extension add WixToolset.Util.wixext

      - name: Build MSI installer (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          wix build -arch x64 -ext WixToolset.UI.wixext -ext WixToolset.Util.wixext -o nameback-${{ matrix.target }}.msi installer/nameback.wxs

      - name: Generate MSI checksum (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $hash = (Get-FileHash -Algorithm SHA256 nameback-${{ matrix.target }}.msi).Hash.ToLower()
          "$hash  nameback-${{ matrix.target }}.msi" | Out-File -Encoding ASCII -Append checksums-windows.txt

      - name: Attest MSI installer (Windows only)
        if: matrix.os == 'windows-latest'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: nameback-${{ matrix.target }}.msi

      - name: Upload MSI installer (Windows only)
        if: matrix.os == 'windows-latest'
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: nameback-${{ matrix.target }}.msi

      - name: Upload checksums as artifact
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.4.3
        with:
          name: checksums-${{ matrix.target }}
          path: checksums-*.txt
          retention-days: 1

  generate-checksums:
    name: Generate Combined Checksums
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    steps:
      - name: Download all checksum artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          pattern: checksums-*
          path: checksums
          merge-multiple: true

      - name: Combine checksums
        run: |
          cat checksums/*.txt > checksums.txt
          echo "Combined checksums:"
          cat checksums.txt

      - name: Upload combined checksums
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: checksums.txt

  # NOTE: crates.io publishing is handled by `cargo release` locally
  # This workflow focuses on building platform-specific binaries (MSI, DMG, DEB)
  # and creating GitHub Releases with those artifacts.

  update-homebrew:
    name: Trigger Homebrew formulae update
    needs: [create-release, build-release, generate-checksums]
    runs-on: ubuntu-latest
    if: ${{ !contains(needs.create-release.outputs.version, '-') }}
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@5d869da34e18e7287c1daad50e0b8ea0f506ce69 # v1.11.0
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: h4x0r
          repositories: homebrew-nameback

      - name: Trigger homebrew-nameback workflow via repository_dispatch
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NO_V=${VERSION#v}

          echo "Sending repository_dispatch event to homebrew-nameback for version ${VERSION_NO_V}..."

          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ steps.app-token.outputs.token }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/h4x0r/homebrew-nameback/dispatches \
            -d "{\"event_type\":\"update-formulae\",\"client_payload\":{\"version\":\"${VERSION_NO_V}\"}}"

          echo "âœ“ Repository dispatch event sent successfully"
          echo "View workflow at: https://github.com/h4x0r/homebrew-nameback/actions"
