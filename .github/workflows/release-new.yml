name: Release

# Force workflow re-registration after branches-ignore removal
on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v0.3.0)'
        required: true
        type: string

permissions:
  contents: write
  id-token: write
  attestations: write

env:
  CARGO_TERM_COLOR: always

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          fetch-depth: 0  # Fetch all history for changelog generation

      - name: Get version from tag
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.tag }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"

      - name: Generate release notes from commits
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 ${VERSION}^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # First release - get all commits
            COMMITS=$(git log --pretty=format:"- %s" --no-merges)
          else
            # Get commits since previous tag
            COMMITS=$(git log --pretty=format:"- %s" --no-merges ${PREV_TAG}..${VERSION})
          fi

          # Generate release notes
          {
            echo "release_notes<<EOF"
            echo "## What's New"
            echo ""
            echo "$COMMITS"
            echo ""
            echo "## Full Changelog"
            if [ -n "$PREV_TAG" ]; then
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${VERSION}"
            fi
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          body: |
            ${{ steps.release_notes.outputs.release_notes }}

            ---

            ## Installation

            ### Windows

            Download and install `nameback-x86_64-pc-windows-msvc.msi`

            **What you get:**
            - ðŸ–¥ï¸ **CLI**: Type `nameback` in any terminal (automatically added to PATH)
            - ðŸŽ¨ **GUI**: Launch from Start Menu â†’ nameback
            - âš™ï¸ **Auto-install dependencies**: exiftool, tesseract, ffmpeg, imagemagick installed automatically

            ### macOS

            **CLI Users (Recommended: Homebrew)**
            ```bash
            brew tap h4x0r/nameback
            brew install nameback
            ```
            Automatically installs all dependencies.

            **GUI Users**
            - Intel Mac: Download `nameback-x86_64-apple-darwin.dmg`
            - Apple Silicon: Download `nameback-aarch64-apple-darwin.dmg`

            Drag to Applications folder and launch!

            ### Linux

            ```bash
            cargo install nameback
            nameback --install-deps
            ```

            ## Verification

            All installers include SHA256 checksums in `checksums.txt`

            ---
            ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
          draft: false
          prerelease: false

  build-release:
    name: Build ${{ matrix.target }}
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            archive: zip

          # macOS Intel
          - target: x86_64-apple-darwin
            os: macos-13
            archive: dmg

          # macOS Apple Silicon
          - target: aarch64-apple-darwin
            os: macos-latest
            archive: dmg

          # Linux (Debian package)
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            archive: deb

    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@21dc36fb71dd22e3317045c0c31a3f4249868b17 # stable
        with:
          toolchain: stable
          targets: ${{ matrix.target }}

      - name: Install dependencies (macOS only)
        if: runner.os == 'macOS'
        run: |
          brew install exiftool tesseract tesseract-lang ffmpeg imagemagick pkg-config

      - name: Cache vcpkg (Windows only)
        if: matrix.os == 'windows-latest'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: C:\vcpkg\installed
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      - name: Install vcpkg and dependencies (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          if (-not (Test-Path C:\vcpkg)) {
            Write-Host "Cloning vcpkg..."
            git clone https://github.com/Microsoft/vcpkg.git C:\vcpkg
          } else {
            Write-Host "vcpkg already exists, skipping clone"
          }
          cd C:\vcpkg
          if (-not (Test-Path .\vcpkg.exe)) {
            Write-Host "Bootstrapping vcpkg..."
            .\bootstrap-vcpkg.bat
          }
          Write-Host "Installing leptonica and tesseract..."
          .\vcpkg integrate install
          .\vcpkg install leptonica:x64-windows-static-md tesseract:x64-windows-static-md

      - name: Set VCPKG_ROOT and triplet (Windows only)
        if: matrix.os == 'windows-latest'
        run: |
          echo "VCPKG_ROOT=C:\vcpkg" >> $GITHUB_ENV
          echo "VCPKGRS_TRIPLET=x64-windows-static-md" >> $GITHUB_ENV
        shell: bash

      - name: Build CLI release binary
        if: matrix.archive != 'deb'
        run: cargo build --release --target ${{ matrix.target }} -p nameback

      - name: Build GUI release binary
        if: matrix.archive != 'deb'
        run: cargo build --release --target ${{ matrix.target }} -p nameback-gui

      - name: Strip binaries (macOS only)
        if: matrix.archive == 'dmg'
        run: |
          strip target/${{ matrix.target }}/release/nameback-gui

      - name: Create DMG installer (macOS only)
        if: matrix.archive == 'dmg'
        run: |
          # Create app bundle structure
          mkdir -p dmg-temp/Nameback.app/Contents/MacOS/bin
          mkdir -p dmg-temp/Nameback.app/Contents/Resources

          # Copy GUI binary
          cp target/${{ matrix.target }}/release/nameback-gui dmg-temp/Nameback.app/Contents/MacOS/nameback-gui
          chmod +x dmg-temp/Nameback.app/Contents/MacOS/nameback-gui

          # Copy CLI binary into app bundle
          cp target/${{ matrix.target }}/release/nameback dmg-temp/Nameback.app/Contents/MacOS/bin/nameback
          chmod +x dmg-temp/Nameback.app/Contents/MacOS/bin/nameback

          # Copy nameback logo as icon (if available)
          if [ -f "docs/nameback.png" ]; then
            # Create iconset for proper macOS app icon
            mkdir -p AppIcon.iconset

            # Generate required icon sizes
            sips -z 16 16     "docs/nameback.png" --out AppIcon.iconset/icon_16x16.png
            sips -z 32 32     "docs/nameback.png" --out AppIcon.iconset/icon_16x16@2x.png
            sips -z 32 32     "docs/nameback.png" --out AppIcon.iconset/icon_32x32.png
            sips -z 64 64     "docs/nameback.png" --out AppIcon.iconset/icon_32x32@2x.png
            sips -z 128 128   "docs/nameback.png" --out AppIcon.iconset/icon_128x128.png
            sips -z 256 256   "docs/nameback.png" --out AppIcon.iconset/icon_128x128@2x.png
            sips -z 256 256   "docs/nameback.png" --out AppIcon.iconset/icon_256x256.png
            sips -z 512 512   "docs/nameback.png" --out AppIcon.iconset/icon_256x256@2x.png
            sips -z 512 512   "docs/nameback.png" --out AppIcon.iconset/icon_512x512.png
            sips -z 1024 1024 "docs/nameback.png" --out AppIcon.iconset/icon_512x512@2x.png

            # Convert iconset to icns
            iconutil -c icns AppIcon.iconset -o dmg-temp/Nameback.app/Contents/Resources/AppIcon.icns

            # Clean up
            rm -rf AppIcon.iconset
          fi

          # Create Info.plist
          cat > dmg-temp/Nameback.app/Contents/Info.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleExecutable</key>
            <string>nameback-gui</string>
            <key>CFBundleIdentifier</key>
            <string>com.securityronin.nameback</string>
            <key>CFBundleName</key>
            <string>Nameback</string>
            <key>CFBundleDisplayName</key>
            <string>Nameback</string>
            <key>CFBundleVersion</key>
            <string>${{ needs.create-release.outputs.version }}</string>
            <key>CFBundleShortVersionString</key>
            <string>${{ needs.create-release.outputs.version }}</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.15</string>
            <key>NSHighResolutionCapable</key>
            <true/>
          </dict>
          </plist>
          EOF

          # Create symlink to /Applications for easy installation
          ln -s /Applications dmg-temp/Applications

          # Copy nameback logo as DMG background
          if [ -f "docs/nameback.png" ]; then
            cp "docs/nameback.png" "dmg-temp/.background.png"
          fi

          # Create DMG with custom appearance using AppleScript
          # First create a temporary DMG
          hdiutil create -volname "Nameback" -srcfolder dmg-temp -ov -format UDRW temp.dmg

          # Mount the DMG
          device=$(hdiutil attach -readwrite -noverify -noautoopen "temp.dmg" | egrep '^/dev/' | sed 1q | awk '{print $1}')

          # Set DMG window properties with AppleScript
          echo '
            tell application "Finder"
              tell disk "Nameback"
                open
                set current view of container window to icon view
                set toolbar visible of container window to false
                set statusbar visible of container window to false
                set the bounds of container window to {100, 100, 700, 500}
                set viewOptions to the icon view options of container window
                set arrangement of viewOptions to not arranged
                set icon size of viewOptions to 128
                set position of item "Nameback.app" of container window to {150, 200}
                set position of item "Applications" of container window to {450, 200}
                close
                open
                update without registering applications
                delay 2
              end tell
            end tell
          ' | osascript

          # Finalize DMG
          chmod -Rf go-w /Volumes/Nameback
          sync
          hdiutil detach ${device}
          hdiutil convert temp.dmg -format UDZO -imagekey zlib-level=9 -o nameback-${{ matrix.target }}.dmg
          rm -f temp.dmg

          # Clean up
          rm -rf dmg-temp

      - name: Generate DMG checksum (macOS only)
        if: matrix.archive == 'dmg'
        run: |
          shasum -a 256 nameback-${{ matrix.target }}.dmg > checksums-${{ matrix.target }}.txt

      - name: Attest DMG installer (macOS only)
        if: matrix.archive == 'dmg'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: nameback-${{ matrix.target }}.dmg

      - name: Install Debian build dependencies (Linux only)
        if: matrix.archive == 'deb'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            debhelper \
            devscripts \
            lintian \
            libimage-exiftool-perl \
            tesseract-ocr \
            ffmpeg \
            imagemagick \
            pkg-config \
            libleptonica-dev \
            libtesseract-dev \
            libclang-dev \
            clang

          # Verify leptonica installation
          echo "Verifying leptonica installation..."
          pkg-config --exists lept && echo "âœ“ lept.pc found" || echo "âœ— lept.pc not found"
          pkg-config --modversion lept || echo "Could not get lept version"
          echo "PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          find /usr -name "lept.pc" 2>/dev/null || echo "lept.pc not found in /usr"

      - name: Build Debian package (Linux only)
        if: matrix.archive == 'deb'
        run: |
          # Set PKG_CONFIG_PATH for the multiarch location
          export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH"
          echo "PKG_CONFIG_PATH is: $PKG_CONFIG_PATH"

          # Verify pkg-config can find lept with the new path
          pkg-config --exists lept && echo "âœ“ pkg-config can find lept" || echo "âœ— pkg-config cannot find lept"
          pkg-config --modversion lept 2>/dev/null && echo "âœ“ lept version: $(pkg-config --modversion lept)" || echo "âœ— Could not get lept version"

          # Build both binaries with PKG_CONFIG_PATH set
          PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH" cargo build --release --workspace

          # Create package structure
          mkdir -p debian-pkg/DEBIAN
          mkdir -p debian-pkg/usr/bin
          mkdir -p debian-pkg/usr/share/applications
          mkdir -p debian-pkg/usr/share/doc/nameback

          # Copy binaries
          cp target/release/nameback debian-pkg/usr/bin/
          cp target/release/nameback-gui debian-pkg/usr/bin/
          chmod 755 debian-pkg/usr/bin/*

          # Copy desktop entry
          cp debian/nameback.desktop debian-pkg/usr/share/applications/

          # Copy documentation
          cp README.md debian-pkg/usr/share/doc/nameback/
          cp LICENSE debian-pkg/usr/share/doc/nameback/copyright

          # Create control file
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NUM=${VERSION#v}  # Remove 'v' prefix
          cat > debian-pkg/DEBIAN/control << EOF
          Package: nameback
          Version: ${VERSION_NUM}-1
          Section: utils
          Priority: optional
          Architecture: amd64
          Depends: libimage-exiftool-perl, tesseract-ocr, tesseract-ocr-chi-tra, tesseract-ocr-chi-sim, ffmpeg, imagemagick
          Maintainer: Albert Hui <albert@example.com>
          Description: Intelligent file renaming based on metadata
           nameback renames files based on their embedded metadata, extracting titles,
           dates, and descriptions to give files meaningful names. It supports a wide
           range of file types including images, videos, PDFs, documents, and more.
           .
           Key Features:
            * Smart metadata extraction from EXIF, PDF, and document fields
            * OCR support for images and video frames (160+ languages)
            * Multi-frame video analysis for better accuracy
            * HEIC/HEIF image support
            * Both CLI and GUI interfaces included
           .
           This package is particularly useful for digital forensics, DFIR workflows,
           organizing recovered files from data recovery tools, and managing large
           photo/video collections.
          Homepage: https://github.com/h4x0r/nameback
          EOF

          # Build .deb package
          dpkg-deb --build --root-owner-group debian-pkg nameback_${VERSION_NUM}-1_amd64.deb

      - name: Run lintian checks (Linux only)
        if: matrix.archive == 'deb'
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NUM=${VERSION#v}
          lintian --no-tag-display-limit nameback_${VERSION_NUM}-1_amd64.deb || true

      - name: Generate DEB checksum (Linux only)
        if: matrix.archive == 'deb'
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NUM=${VERSION#v}
          sha256sum nameback_${VERSION_NUM}-1_amd64.deb > checksums-linux.txt

      - name: Attest Debian package (Linux only)
        if: matrix.archive == 'deb'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: |
            nameback_*_amd64.deb

      - name: Upload Debian package to release (Linux only)
        if: matrix.archive == 'deb'
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: |
            nameback_*_amd64.deb

      - name: Create archive with CLI and GUI (Windows)
        if: matrix.archive == 'zip'
        shell: pwsh
        run: |
          cd target/${{ matrix.target }}/release
          Compress-Archive -Path nameback.exe,nameback-gui.exe -DestinationPath ../../../nameback-${{ matrix.target }}.zip
          cd ../../..

      - name: Generate ZIP checksum (Windows)
        if: matrix.archive == 'zip'
        shell: pwsh
        run: |
          $hash = (Get-FileHash -Algorithm SHA256 nameback-${{ matrix.target }}.zip).Hash.ToLower()
          "$hash  nameback-${{ matrix.target }}.zip" | Out-File -Encoding ASCII checksums-windows.txt

      - name: Attest ZIP archive (Windows only)
        if: matrix.archive == 'zip'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: nameback-${{ matrix.target }}.zip

      - name: Upload installer to release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: |
            nameback-${{ matrix.target }}.${{ matrix.archive }}

      - name: Install WiX Toolset (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          dotnet tool install --global wix
          wix extension add -g WixToolset.UI.wixext

      - name: Build MSI installer (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          wix build -arch x64 -o nameback-${{ matrix.target }}.msi installer/nameback.wxs

      - name: Generate MSI checksum (Windows only)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $hash = (Get-FileHash -Algorithm SHA256 nameback-${{ matrix.target }}.msi).Hash.ToLower()
          "$hash  nameback-${{ matrix.target }}.msi" | Out-File -Encoding ASCII -Append checksums-windows.txt

      - name: Attest MSI installer (Windows only)
        if: matrix.os == 'windows-latest'
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: nameback-${{ matrix.target }}.msi

      - name: Upload MSI installer (Windows only)
        if: matrix.os == 'windows-latest'
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: nameback-${{ matrix.target }}.msi

      - name: Upload checksums as artifact
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.4.3
        with:
          name: checksums-${{ matrix.target }}
          path: checksums-*.txt
          retention-days: 1

  generate-checksums:
    name: Generate Combined Checksums
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    steps:
      - name: Download all checksum artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          pattern: checksums-*
          path: checksums
          merge-multiple: true

      - name: Combine checksums
        run: |
          cat checksums/*.txt > checksums.txt
          echo "Combined checksums:"
          cat checksums.txt

      - name: Upload combined checksums
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: checksums.txt

  # NOTE: crates.io publishing is handled by `cargo release` locally
  # This workflow focuses on building platform-specific binaries (MSI, DMG, DEB)
  # and creating GitHub Releases with those artifacts.

  update-homebrew:
    name: Update Homebrew formulae
    needs: [create-release, build-release, upload-release-artifacts]
    runs-on: ubuntu-latest
    if: ${{ !contains(needs.create-release.outputs.version, '-') }}
    steps:
      - name: Checkout nameback repo
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Checkout homebrew-nameback repo
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          repository: h4x0r/homebrew-nameback
          token: ${{ secrets.GITHUB_TOKEN }}
          path: homebrew-nameback

      - name: Download release artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          gh release download ${VERSION} -p "*.dmg" -p "checksums.txt"

      - name: Extract checksums for macOS
        id: checksums
        run: |
          INTEL_SHA=$(grep "nameback-x86_64-apple-darwin.dmg" checksums.txt | awk '{print $1}')
          ARM_SHA=$(grep "nameback-aarch64-apple-darwin.dmg" checksums.txt | awk '{print $1}')
          echo "intel_sha=${INTEL_SHA}" >> $GITHUB_OUTPUT
          echo "arm_sha=${ARM_SHA}" >> $GITHUB_OUTPUT
          echo "Extracted Intel SHA: ${INTEL_SHA}"
          echo "Extracted ARM SHA: ${ARM_SHA}"

      - name: Update Homebrew formula (CLI)
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NO_V=${VERSION#v}

          cd homebrew-nameback

          # Update CLI formula
          sed -i "s/version \".*\"/version \"${VERSION_NO_V}\"/" Formula/nameback.rb
          sed -i "s|url \".*\"|url \"https://github.com/h4x0r/nameback/releases/download/${VERSION}/nameback-x86_64-apple-darwin.dmg\"|" Formula/nameback.rb
          sed -i "s/sha256 \".*\"/sha256 \"${{ steps.checksums.outputs.intel_sha }}\"/" Formula/nameback.rb

          echo "Updated Formula/nameback.rb:"
          cat Formula/nameback.rb

      - name: Update Homebrew cask (GUI)
        run: |
          VERSION=${{ needs.create-release.outputs.version }}
          VERSION_NO_V=${VERSION#v}

          cd homebrew-nameback

          # Update GUI cask - using both Intel and ARM builds
          sed -i "s/version \".*\"/version \"${VERSION_NO_V}\"/" Casks/nameback.rb

          # Update Intel build SHA
          sed -i "0,/sha256 \".*\"/s/sha256 \".*\"/sha256 \"${{ steps.checksums.outputs.intel_sha }}\"/" Casks/nameback.rb

          # Update ARM build SHA (second occurrence)
          sed -i "0,/sha256 \".*\"/!s/sha256 \".*\"/sha256 \"${{ steps.checksums.outputs.arm_sha }}\"/" Casks/nameback.rb

          echo "Updated Casks/nameback.rb:"
          cat Casks/nameback.rb

      - name: Commit and push changes
        run: |
          cd homebrew-nameback
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Formula/nameback.rb Casks/nameback.rb
          git commit -m "chore: update to version ${{ needs.create-release.outputs.version }}"
          git push
